<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cudd: cudd/cuddApprox.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cudd/cuddApprox.c File Reference</h1>
<p>Procedures to approximate a given BDD.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="cuddInt_8h_source.html">cuddInt.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for cuddApprox.c:</div>
<div class="dynsection">
<div class="center"><img src="cuddApprox_8c__incl.png" border="0" usemap="#cudd_2cuddApprox_8c_map" alt=""/></div>
<map name="cudd_2cuddApprox_8c_map" id="cudd_2cuddApprox_8c">
<area shape="rect" id="node3" href="util_8h.html" title="Low&#45;level utilities." alt="" coords="612,83,663,112"/><area shape="rect" id="node21" href="cuddInt_8h.html" title="Internal data structures of the CUDD package." alt="" coords="217,83,292,112"/><area shape="rect" id="node5" href="config_8h_source.html" title="config.h" alt="" coords="395,160,461,189"/><area shape="rect" id="node26" href="st_2st_8h.html" title="Symbol table package." alt="" coords="5,160,48,189"/><area shape="rect" id="node28" href="mtr_2mtr_8h.html" title="Multiway&#45;branch tree manipulation." alt="" coords="72,160,123,189"/><area shape="rect" id="node31" href="epd_2epd_8h.html" title="The University of Colorado extended double precision package." alt="" coords="147,160,200,189"/><area shape="rect" id="node33" href="cudd_8h.html" title="The University of Colorado decision diagram package." alt="" coords="309,160,371,189"/></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeData.html">NodeData</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Data structure to store the information on each node.  <a href="structNodeData.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structApproxInfo.html">ApproxInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main bookkeeping data structure for approximation algorithms.  <a href="structApproxInfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGlobalQueueItem.html">GlobalQueueItem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Item of the queue used in the levelized traversal of the BDD.  <a href="structGlobalQueueItem.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLocalQueueItem.html">LocalQueueItem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the item of the local queue.  <a href="structLocalQueueItem.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a539f2dd258b96fac8f4dc9bc139d75c9"></a><!-- doxytag: member="cuddApprox.c::DBL_MAX_EXP" ref="a539f2dd258b96fac8f4dc9bc139d75c9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DBL_MAX_EXP</b>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad4a7ebff687dc5228cc3fd4d25067f2"></a><!-- doxytag: member="cuddApprox.c::NOTHING" ref="aad4a7ebff687dc5228cc3fd4d25067f2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NOTHING</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfdeecb8041ec64c51bf6ac8ada9b85f"></a><!-- doxytag: member="cuddApprox.c::REPLACE_T" ref="abfdeecb8041ec64c51bf6ac8ada9b85f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPLACE_T</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f4c5f60b46c48f9ba8d940e91e936b"></a><!-- doxytag: member="cuddApprox.c::REPLACE_E" ref="ac0f4c5f60b46c48f9ba8d940e91e936b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPLACE_E</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8730fda1e81e2be695fc98b7ea56b1d0"></a><!-- doxytag: member="cuddApprox.c::REPLACE_N" ref="a8730fda1e81e2be695fc98b7ea56b1d0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPLACE_N</b>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af328b37c5dce977e36a8cad72a5a5075"></a><!-- doxytag: member="cuddApprox.c::REPLACE_TT" ref="af328b37c5dce977e36a8cad72a5a5075" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPLACE_TT</b>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a887382ed988ce99032ca7190eb6cc0c8"></a><!-- doxytag: member="cuddApprox.c::REPLACE_TE" ref="a887382ed988ce99032ca7190eb6cc0c8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPLACE_TE</b>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdc326bd5037b2251e62f398ab1b48d1"></a><!-- doxytag: member="cuddApprox.c::DONT_CARE" ref="afdc326bd5037b2251e62f398ab1b48d1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>DONT_CARE</b>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4b6aef9340c072016ab76545623c234"></a><!-- doxytag: member="cuddApprox.c::CARE" ref="ac4b6aef9340c072016ab76545623c234" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CARE</b>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b99ae0b8c217b6026b3a21c5d8087e5"></a><!-- doxytag: member="cuddApprox.c::TOTAL_CARE" ref="a2b99ae0b8c217b6026b3a21c5d8087e5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TOTAL_CARE</b>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0719cbe48fbd438b529ae22512a79077"></a><!-- doxytag: member="cuddApprox.c::CARE_ERROR" ref="a0719cbe48fbd438b529ae22512a79077" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CARE_ERROR</b>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9">Cudd_UnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a dense subset from a BDD with Shiple's underapproximation method.  <a href="#a9381231f34573676e814bb696b2321c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a09e725e579f19ac3e946c04cfdde95f0">Cudd_OverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a dense superset from a BDD with Shiple's underapproximation method.  <a href="#a09e725e579f19ac3e946c04cfdde95f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3">Cudd_RemapUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a dense subset from a BDD with the remapping underapproximation method.  <a href="#a05f3e8b16e5df2eb681a68e6ee6906f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38">Cudd_RemapOverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a dense superset from a BDD with the remapping underapproximation method.  <a href="#a88270c8ded877c10677d563b7041df38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2">Cudd_BiasedUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a dense subset from a BDD with the biased underapproximation method.  <a href="#a9fe204aedfdf7705234573d8781729e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#ab6ecb253ad0a11cc9430f0d527e6eaa0">Cudd_BiasedOverApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a dense superset from a BDD with the biased underapproximation method.  <a href="#ab6ecb253ad0a11cc9430f0d527e6eaa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b">cuddUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, int safe, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies Tom Shiple's underappoximation algorithm.  <a href="#a9f4ad4116db7673ca7b4b829ecb7197b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#afd6a96316d8465015470b02486ffaa86">cuddRemapUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, int numVars, int threshold, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the remapping underappoximation algorithm.  <a href="#afd6a96316d8465015470b02486ffaa86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a60bdad03bfa7e367b6b3efa7aa1e4c37">cuddBiasedUnderApprox</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, int numVars, int threshold, double quality1, double quality0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the biased remapping underappoximation algorithm.  <a href="#a60bdad03bfa7e367b6b3efa7aa1e4c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a786a1a3993926ee9220dd8871202b9c0">updateParity</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int newparity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively update the parity of the paths reaching a node.  <a href="#a786a1a3993926ee9220dd8871202b9c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structNodeData.html">NodeData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a52ef9bff746f26b7676a9b6bf306aff0">gatherInfoAux</a> (<a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int parity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively counts minterms and computes reference counts of each node in the BDD.  <a href="#a52ef9bff746f26b7676a9b6bf306aff0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#ae44b2baafcdc4ec512e949ca16c527e8">gatherInfo</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, int numVars, int parity)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gathers information about each node.  <a href="#ae44b2baafcdc4ec512e949ca16c527e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#afdfefa6bdb3878c328ba8fafa81794d1">computeSavings</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *skip, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, <a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Counts the nodes that would be eliminated if a given node were replaced by zero.  <a href="#afdfefa6bdb3878c328ba8fafa81794d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a8db9c0f4accec76346cfba7cf37070a3">updateRefs</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *skip, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, <a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *queue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update function reference counts to account for replacement.  <a href="#a8db9c0f4accec76346cfba7cf37070a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a725a9cfe2c41f58f7f9f6ef1476965a8">UAmarkNodes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int threshold, int safe, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks nodes for replacement by zero.  <a href="#a725a9cfe2c41f58f7f9f6ef1476965a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#aa7917aa7316c2bd90322cd38efe86043">UAbuildSubset</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds the subset BDD.  <a href="#aa7917aa7316c2bd90322cd38efe86043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a5cbc7c83d55240241ce3316405b46a7a">RAmarkNodes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int threshold, double quality)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks nodes for remapping.  <a href="#a5cbc7c83d55240241ce3316405b46a7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#af7f29212597e4553e259c59cb052c4e5">BAmarkNodes</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, int threshold, double quality1, double quality0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks nodes for remapping.  <a href="#af7f29212597e4553e259c59cb052c4e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a2a86508a00e350303c4d38de496dc03f">RAbuildSubset</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *node, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds the subset BDD for cuddRemapUnderApprox.  <a href="#a2a86508a00e350303c4d38de496dc03f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="cuddApprox_8c.html#a89d043119bb74e254d28502e00124165">BAapplyBias</a> (<a class="el" href="structDdManager.html">DdManager</a> *dd, <a class="el" href="structDdNode.html">DdNode</a> *f, <a class="el" href="structDdNode.html">DdNode</a> *b, <a class="el" href="structApproxInfo.html">ApproxInfo</a> *info, <a class="el" href="structDdHashTable.html">DdHashTable</a> *cache)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds don't care nodes by traversing f and b in parallel.  <a href="#a89d043119bb74e254d28502e00124165"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Procedures to approximate a given BDD. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetHB_8c.html" title="Procedure to subset the given BDD by choosing the heavier branches.">cuddSubsetHB.c</a> <a class="el" href="cuddSubsetSP_8c.html" title="Procedure to subset the given BDD choosing the shortest paths (largest cubes) in...">cuddSubsetSP.c</a> <a class="el" href="cuddGenCof_8c.html" title="Generalized cofactors for BDDs and ADDs.">cuddGenCof.c</a></dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>Fabio Somenzi</dd></dl>
<p>Copyright (c) 1995-2015, Regents of the University of Colorado</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>Neither the name of the University of Colorado nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a89d043119bb74e254d28502e00124165"></a><!-- doxytag: member="cuddApprox.c::BAapplyBias" ref="a89d043119bb74e254d28502e00124165" args="(DdManager *dd, DdNode *f, DdNode *b, ApproxInfo *info, DdHashTable *cache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int BAapplyBias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdHashTable.html">DdHashTable</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds don't care nodes by traversing f and b in parallel. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the care status of the visited f node if successful; CARE_ERROR otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a60bdad03bfa7e367b6b3efa7aa1e4c37" title="Applies the biased remapping underappoximation algorithm.">cuddBiasedUnderApprox</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af7f29212597e4553e259c59cb052c4e5"></a><!-- doxytag: member="cuddApprox.c::BAmarkNodes" ref="af7f29212597e4553e259c59cb052c4e5" args="(DdManager *dd, DdNode *f, ApproxInfo *info, int threshold, double quality1, double quality0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int BAmarkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks nodes for remapping. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a60bdad03bfa7e367b6b3efa7aa1e4c37" title="Applies the biased remapping underappoximation algorithm.">cuddBiasedUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be analyzed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>info on BDD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximating </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality1</em>&nbsp;</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality0</em>&nbsp;</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdfefa6bdb3878c328ba8fafa81794d1"></a><!-- doxytag: member="cuddApprox.c::computeSavings" ref="afdfefa6bdb3878c328ba8fafa81794d1" args="(DdManager *dd, DdNode *f, DdNode *skip, ApproxInfo *info, DdLevelQueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int computeSavings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Counts the nodes that would be eliminated if a given node were replaced by zero. </p>
<p>This procedure uses a queue passed by the caller for efficiency: since the queue is left empty at the endof the search, it can be reused as is by the next search.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the count (always striclty positive) if successful; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a725a9cfe2c41f58f7f9f6ef1476965a8" title="Marks nodes for replacement by zero.">UAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#a5cbc7c83d55240241ce3316405b46a7a" title="Marks nodes for remapping.">RAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#af7f29212597e4553e259c59cb052c4e5" title="Marks nodes for remapping.">BAmarkNodes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6ecb253ad0a11cc9430f0d527e6eaa0"></a><!-- doxytag: member="cuddApprox.c::Cudd_BiasedOverApprox" ref="ab6ecb253ad0a11cc9430f0d527e6eaa0" args="(DdManager *dd, DdNode *f, DdNode *b, int numVars, int threshold, double quality1, double quality0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BiasedOverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a dense superset from a BDD with the biased underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddApprox_8c.html#a88270c8ded877c10677d563b7041df38" title="Extracts a dense superset from a BDD with the remapping underapproximation method...">Cudd_RemapOverApprox</a> <a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2" title="Extracts a dense subset from a BDD with the biased underapproximation method.">Cudd_BiasedUnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be superset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>bias function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>number of variables in the support of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality1</em>&nbsp;</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality0</em>&nbsp;</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fe204aedfdf7705234573d8781729e2"></a><!-- doxytag: member="cuddApprox.c::Cudd_BiasedUnderApprox" ref="a9fe204aedfdf7705234573d8781729e2" args="(DdManager *dd, DdNode *f, DdNode *b, int numVars, int threshold, double quality1, double quality0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_BiasedUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a dense subset from a BDD with the biased underapproximation method. </p>
<p>This procedure uses a biased remapping technique and density as the cost function. The bias is a function. This procedure tries to approximate where the bias is 0 and preserve the given function where the bias is 1. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> <a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be subset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>bias function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>number of variables in the support of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality1</em>&nbsp;</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality0</em>&nbsp;</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09e725e579f19ac3e946c04cfdde95f0"></a><!-- doxytag: member="cuddApprox.c::Cudd_OverApprox" ref="a09e725e579f19ac3e946c04cfdde95f0" args="(DdManager *dd, DdNode *f, int numVars, int threshold, int safe, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_OverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a dense superset from a BDD with Shiple's underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be superset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>number of variables in the support of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>safe</em>&nbsp;</td><td>enforce safe approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88270c8ded877c10677d563b7041df38"></a><!-- doxytag: member="cuddApprox.c::Cudd_RemapOverApprox" ref="a88270c8ded877c10677d563b7041df38" args="(DdManager *dd, DdNode *f, int numVars, int threshold, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_RemapOverApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a dense superset from a BDD with the remapping underapproximation method. </p>
<p>The procedure is identical to the underapproximation procedure except for the fact that it works on the complement of the given function. Extracting the subset of the complement function is equivalent to extracting the superset of the function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD of the superset if successful. NULL if intermediate result causes the procedure to run out of memory.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetHB_8c.html#a5562f42d8ed481485bcb9d5469b2cedd" title="Extracts a dense superset from a BDD with the heavy branch heuristic.">Cudd_SupersetHeavyBranch</a> <a class="el" href="cuddSubsetSP_8c.html#a64d8ed34596ee3ef413bc804f08de8f7" title="Extracts a dense superset from a BDD with the shortest paths heuristic.">Cudd_SupersetShortPaths</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be superset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>number of variables in the support of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05f3e8b16e5df2eb681a68e6ee6906f3"></a><!-- doxytag: member="cuddApprox.c::Cudd_RemapUnderApprox" ref="a05f3e8b16e5df2eb681a68e6ee6906f3" args="(DdManager *dd, DdNode *f, int numVars, int threshold, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_RemapUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a dense subset from a BDD with the remapping underapproximation method. </p>
<p>This procedure uses a remapping technique and density as the cost function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD of the subset if successful. NULL if the procedure runs out of memory.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be subset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>number of variables in the support of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9381231f34573676e814bb696b2321c9"></a><!-- doxytag: member="cuddApprox.c::Cudd_UnderApprox" ref="a9381231f34573676e814bb696b2321c9" args="(DdManager *dd, DdNode *f, int numVars, int threshold, int safe, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* Cudd_UnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a dense subset from a BDD with Shiple's underapproximation method. </p>
<p>This procedure uses a variant of Tom Shiple's underapproximation method. The main difference from the original method is that density is used as cost function. The parameter numVars is the maximum number of variables to be used in minterm calculation. The optimal number should be as close as possible to the size of the support of f. However, it is safe to pass the value returned by Cudd_ReadSize for numVars when the number of variables is under 1023. If numVars is larger than 1023, it will cause overflow. If a 0 parameter is passed then the procedure will compute a value which will avoid overflow but will cause underflow with 2046 variables or more.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the BDD of the subset if successful; NULL if the procedure runs out of memory.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddSubsetSP_8c.html#a890a2da46a4d6cec913e2ae57a9ab626" title="Extracts a dense subset from a BDD with the shortest paths heuristic.">Cudd_SubsetShortPaths</a> <a class="el" href="cuddSubsetHB_8c.html#a7579ecbb0187c4061cc2d45a3a21e68e" title="Extracts a dense subset from a BDD with the heavy branch heuristic.">Cudd_SubsetHeavyBranch</a> <a class="el" href="cuddAPI_8c.html#ab1647f3f86f4e555bea35673f9539f94" title="Returns the number of BDD variables in existance.">Cudd_ReadSize</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be subset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>number of variables in the support of f </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>safe</em>&nbsp;</td><td>enforce safe approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60bdad03bfa7e367b6b3efa7aa1e4c37"></a><!-- doxytag: member="cuddApprox.c::cuddBiasedUnderApprox" ref="a60bdad03bfa7e367b6b3efa7aa1e4c37" args="(DdManager *dd, DdNode *f, DdNode *b, int numVars, int threshold, double quality1, double quality0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddBiasedUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the biased remapping underappoximation algorithm. </p>
<p>Proceeds in three phases: </p>
<ul>
<li>
collect information on each node in the BDD; this is done via DFS. </li>
<li>
traverse the BDD in top-down fashion and compute for each node whether remapping increases density. </li>
<li>
traverse the BDD via DFS and actually perform the elimination. </li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the approximated BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a9fe204aedfdf7705234573d8781729e2" title="Extracts a dense subset from a BDD with the biased underapproximation method.">Cudd_BiasedUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>DD manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>current DD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>bias function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>maximum number of variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>threshold under which approximation stops </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality1</em>&nbsp;</td><td>minimum improvement for accepted changes when b=1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality0</em>&nbsp;</td><td>minimum improvement for accepted changes when b=0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd6a96316d8465015470b02486ffaa86"></a><!-- doxytag: member="cuddApprox.c::cuddRemapUnderApprox" ref="afd6a96316d8465015470b02486ffaa86" args="(DdManager *dd, DdNode *f, int numVars, int threshold, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddRemapUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the remapping underappoximation algorithm. </p>
<p>Proceeds in three phases: </p>
<ul>
<li>
collect information on each node in the BDD; this is done via DFS. </li>
<li>
traverse the BDD in top-down fashion and compute for each node whether remapping increases density. </li>
<li>
traverse the BDD via DFS and actually perform the elimination. </li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the approximated BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a05f3e8b16e5df2eb681a68e6ee6906f3" title="Extracts a dense subset from a BDD with the remapping underapproximation method.">Cudd_RemapUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>DD manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>current DD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>maximum number of variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>threshold under which approximation stops </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f4ad4116db7673ca7b4b829ecb7197b"></a><!-- doxytag: member="cuddApprox.c::cuddUnderApprox" ref="a9f4ad4116db7673ca7b4b829ecb7197b" args="(DdManager *dd, DdNode *f, int numVars, int threshold, int safe, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDdNode.html">DdNode</a>* cuddUnderApprox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies Tom Shiple's underappoximation algorithm. </p>
<p>Proceeds in three phases: </p>
<ul>
<li>
collect information on each node in the BDD; this is done via DFS. </li>
<li>
traverse the BDD in top-down fashion and compute for each node whether its elimination increases density. </li>
<li>
traverse the BDD via DFS and actually perform the elimination. </li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>the approximated BDD if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a9381231f34573676e814bb696b2321c9" title="Extracts a dense subset from a BDD with Shiple&#39;s underapproximation method.">Cudd_UnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>DD manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>current DD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numVars</em>&nbsp;</td><td>maximum number of variables </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>threshold under which approximation stops </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>safe</em>&nbsp;</td><td>enforce safe approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae44b2baafcdc4ec512e949ca16c527e8"></a><!-- doxytag: member="cuddApprox.c::gatherInfo" ref="ae44b2baafcdc4ec512e949ca16c527e8" args="(DdManager *dd, DdNode *node, int numVars, int parity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structApproxInfo.html">ApproxInfo</a>* gatherInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>parity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gathers information about each node. </p>
<p>Counts minterms and computes reference counts of each node in the BDD. The minterm count is separately computed for the node and its complement. This is to avoid cancellation errors.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the data structure holding the information gathered if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b" title="Applies Tom Shiple&#39;s underappoximation algorithm.">cuddUnderApprox</a> <a class="el" href="cuddApprox_8c.html#a52ef9bff746f26b7676a9b6bf306aff0" title="Recursively counts minterms and computes reference counts of each node in the BDD...">gatherInfoAux</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52ef9bff746f26b7676a9b6bf306aff0"></a><!-- doxytag: member="cuddApprox.c::gatherInfoAux" ref="a52ef9bff746f26b7676a9b6bf306aff0" args="(DdNode *node, ApproxInfo *info, int parity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structNodeData.html">NodeData</a>* gatherInfoAux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>parity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively counts minterms and computes reference counts of each node in the BDD. </p>
<p>Similar to the cuddCountMintermAux which recursively counts the number of minterms for the dag rooted at each node in terms of the total number of variables (max). It assumes that the node pointer passed to it is regular and it maintains the invariant.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#ae44b2baafcdc4ec512e949ca16c527e8" title="Gathers information about each node.">gatherInfo</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>function to analyze </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>info on BDD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parity</em>&nbsp;</td><td>gather parity information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a86508a00e350303c4d38de496dc03f"></a><!-- doxytag: member="cuddApprox.c::RAbuildSubset" ref="a2a86508a00e350303c4d38de496dc03f" args="(DdManager *dd, DdNode *node, ApproxInfo *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* RAbuildSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds the subset BDD for cuddRemapUnderApprox. </p>
<p>Based on the info table, performs remapping or replacement at selected nodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#afd6a96316d8465015470b02486ffaa86" title="Applies the remapping underappoximation algorithm.">cuddRemapUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>DD manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>current node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>node info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cbc7c83d55240241ce3316405b46a7a"></a><!-- doxytag: member="cuddApprox.c::RAmarkNodes" ref="a5cbc7c83d55240241ce3316405b46a7a" args="(DdManager *dd, DdNode *f, ApproxInfo *info, int threshold, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int RAmarkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks nodes for remapping. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#afd6a96316d8465015470b02486ffaa86" title="Applies the remapping underappoximation algorithm.">cuddRemapUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be analyzed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>info on BDD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximating </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7917aa7316c2bd90322cd38efe86043"></a><!-- doxytag: member="cuddApprox.c::UAbuildSubset" ref="aa7917aa7316c2bd90322cd38efe86043" args="(DdManager *dd, DdNode *node, ApproxInfo *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structDdNode.html">DdNode</a>* UAbuildSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds the subset BDD. </p>
<p>Based on the info table, replaces selected nodes by zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the result if successful; NULL otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b" title="Applies Tom Shiple&#39;s underappoximation algorithm.">cuddUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>DD manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>current node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>node info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a725a9cfe2c41f58f7f9f6ef1476965a8"></a><!-- doxytag: member="cuddApprox.c::UAmarkNodes" ref="a725a9cfe2c41f58f7f9f6ef1476965a8" args="(DdManager *dd, DdNode *f, ApproxInfo *info, int threshold, int safe, double quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int UAmarkNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>safe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>quality</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks nodes for replacement by zero. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if successful; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a9f4ad4116db7673ca7b4b829ecb7197b" title="Applies Tom Shiple&#39;s underappoximation algorithm.">cuddUnderApprox</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dd</em>&nbsp;</td><td>manager </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>function to be analyzed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>info on BDD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>when to stop approximating </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>safe</em>&nbsp;</td><td>enforce safe approximation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>quality</em>&nbsp;</td><td>minimum improvement for accepted changes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a786a1a3993926ee9220dd8871202b9c0"></a><!-- doxytag: member="cuddApprox.c::updateParity" ref="a786a1a3993926ee9220dd8871202b9c0" args="(DdNode *node, ApproxInfo *info, int newparity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void updateParity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newparity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively update the parity of the paths reaching a node. </p>
<p>Assumes that node is regular and propagates the invariant.</p>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a52ef9bff746f26b7676a9b6bf306aff0" title="Recursively counts minterms and computes reference counts of each node in the BDD...">gatherInfoAux</a> </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>function to analyze </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>info on BDD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newparity</em>&nbsp;</td><td>new parity for node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8db9c0f4accec76346cfba7cf37070a3"></a><!-- doxytag: member="cuddApprox.c::updateRefs" ref="a8db9c0f4accec76346cfba7cf37070a3" args="(DdManager *dd, DdNode *f, DdNode *skip, ApproxInfo *info, DdLevelQueue *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int updateRefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDdManager.html">DdManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdNode.html">DdNode</a> *&nbsp;</td>
          <td class="paramname"> <em>skip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structApproxInfo.html">ApproxInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDdLevelQueue.html">DdLevelQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>queue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update function reference counts to account for replacement. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of nodes saved if successful; 0 otherwise.</dd></dl>
<dl class="user"><dt><b>Side effects</b></dt><dd>None</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="cuddApprox_8c.html#a725a9cfe2c41f58f7f9f6ef1476965a8" title="Marks nodes for replacement by zero.">UAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#a5cbc7c83d55240241ce3316405b46a7a" title="Marks nodes for remapping.">RAmarkNodes</a> <a class="el" href="cuddApprox_8c.html#af7f29212597e4553e259c59cb052c4e5" title="Marks nodes for remapping.">BAmarkNodes</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Jul 2017 for cudd by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
